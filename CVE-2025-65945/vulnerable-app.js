/**
 * CVE-2025-65945 - Vulnerable Application
 * 
 * This application demonstrates the vulnerability in jws < 3.2.3 where
 * an attacker can bypass signature verification by manipulating the JWT header
 * to influence the secret lookup process.
 * 
 * Vulnerability: When using createVerify() with HS256 and user-provided data
 * from JWT header/payload in secret lookup routines, an attacker can pass
 * null/undefined to bypass signature verification.
 */

const express = require('express');
const bodyParser = require('body-parser');
const jws = require('jws');
const path = require('path');

const app = express();
app.use(bodyParser.json());
app.use(express.static('public'));

// Simulated user database
const users = {
  'user1': {
    username: 'user1',
    role: 'user',
    secret: 'user1-secret-key-12345'
  },
  'admin': {
    username: 'admin',
    role: 'admin',
    secret: 'super-secret-admin-key-67890'
  }
};

// Protected resources
const sensitiveData = {
  user: 'ðŸ“„ User Level Data: Your personal profile information, basic settings, and public data.',
  admin: 'ðŸ” ADMIN LEVEL SENSITIVE DATA: Database password: db_P@ssw0rd123, AWS API Key: AKIA1234567890ABCDEF, Root SSH Keys, Production Server Access, Customer PII Database'
};

/**
 * VULNERABLE FUNCTION - SIMPLIFIED VERSION
 * 
 * This function uses user-provided data from JWT header (the 'user' field)
 * to lookup the secret. An attacker can manipulate this field to return
 * null/undefined, which bypasses signature verification in vulnerable jws versions.
 * 
 * Using jws.verify() directly for simplicity
 */
async function verifyToken(token) {
  try {
    // Decode JWT to get header
    const decoded = jws.decode(token);
    
    if (!decoded || !decoded.header) {
      return { valid: false, error: 'Invalid token format' };
    }

    // Parse payload if it's a string
    let payload = decoded.payload;
    if (typeof payload === 'string') {
      try {
        payload = JSON.parse(payload);
      } catch (e) {
        console.log(`[DEBUG] Failed to parse payload: ${e.message}`);
      }
    }

    console.log(`[DEBUG] Decoded payload:`, JSON.stringify(payload));

    // VULNERABILITY: Using user-provided data from header to lookup secret
    // If attacker sets user to a non-existent value, this returns undefined
    const username = decoded.header.user;
    const user = users[username]; // This can return undefined!
    
    console.log(`[DEBUG] Looking up user: ${username}`);
    console.log(`[DEBUG] User found: ${user ? 'Yes' : 'No'}`);
    console.log(`[DEBUG] Secret: ${user ? user.secret : 'undefined'}`);

    // Get algorithm from header (also user-controlled)
    const algorithm = decoded.header.alg;
    const secret = user ? user.secret : undefined;

    console.log(`[DEBUG] Attempting verification with algorithm: ${algorithm}, secret: ${secret ? 'defined' : 'undefined'}`);

    // VULNERABILITY: In jws < 3.2.3, undefined secret bypasses verification
    // The verify function should fail but doesn't properly validate
    let valid = false;
    try {
      valid = jws.verify(token, algorithm, secret);
      console.log(`[DEBUG] jws.verify() result: ${valid}`);
    } catch (verifyError) {
      console.log(`[DEBUG] jws.verify() threw error: ${verifyError.message}`);
      
      // In vulnerable versions, error with undefined might actually mean bypass
      // For demo purposes, if secret is undefined and algorithm is HS*, treat as valid
      // This simulates the vulnerability behavior
      if (!secret && algorithm && algorithm.toLowerCase().startsWith('hs')) {
        console.log(`[DEBUG] âš ï¸ VULNERABILITY: undefined secret with HMAC - BYPASSING VERIFICATION!`);
        valid = true;
      }
    }

    if (valid) {
      // VULNERABILITY: When secret is undefined (user not found), 
      // we should ACCEPT the role from payload (attacker-controlled!)
      // This is the exploit - attacker can claim any role!
      let role;
      if (user) {
        // Normal case: user exists, use their actual role
        role = user.role;
      } else {
        // EXPLOIT case: user doesn't exist (undefined secret)
        // Accept whatever role is in the payload - THIS IS THE VULNERABILITY!
        role = payload.role || 'user';
      }
      
      console.log(`[DEBUG] âœ… Token accepted - User: ${payload.username || username}, Role: ${role}`);
      console.log(`[DEBUG] User found in DB: ${user ? 'Yes' : 'No (EXPLOIT!)'}`);
      
      return {
        valid: true,
        payload: payload,
        user: payload.username || username,
        role: role
      };
    } else {
      console.log(`[DEBUG] âŒ Token rejected - Invalid signature`);
      return { valid: false, error: 'Invalid signature' };
    }

  } catch (err) {
    console.log(`[DEBUG] Exception in verifyToken: ${err.message}`);
    return { valid: false, error: err.message };
  }
}

// Login endpoint - generates valid JWT tokens
app.post('/login', (req, res) => {
  const { username, password } = req.body;

  // Simple authentication (for demo purposes)
  if (username === 'user1' && password === 'password1') {
    const user = users[username];
    const token = jws.sign({
      header: { alg: 'HS256', user: username },
      payload: { username: username, role: user.role },
      secret: user.secret
    });

    res.json({
      success: true,
      token: token,
      message: 'Login successful'
    });
  } else if (username === 'admin' && password === 'admin123') {
    const user = users[username];
    const token = jws.sign({
      header: { alg: 'HS256', user: username },
      payload: { username: username, role: user.role },
      secret: user.secret
    });

    res.json({
      success: true,
      token: token,
      message: 'Admin login successful'
    });
  } else {
    res.status(401).json({
      success: false,
      message: 'Invalid credentials'
    });
  }
});

// Protected endpoint - requires valid JWT
app.get('/data', async (req, res) => {
  const authHeader = req.headers['authorization'];

  if (!authHeader) {
    return res.status(401).json({
      success: false,
      message: 'No authorization header'
    });
  }

  const token = authHeader.replace('Bearer ', '');

  const result = await verifyToken(token);

  if (result.valid) {
    // Return data based on role
    const role = result.role || 'user';
    const data = sensitiveData[role] || sensitiveData.user;
    
    console.log(`[DEBUG] Returning data for role: ${role}`);
    console.log(`[DEBUG] Data: ${data}`);
    
    res.json({
      success: true,
      message: 'Access granted',
      username: result.user,
      role: role,
      data: data
    });
  } else {
    res.status(401).json({
      success: false,
      message: 'Invalid or expired token',
      error: result.error
    });
  }
});

// Info endpoint
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

app.get('/api/info', (req, res) => {
  res.json({
    app: 'CVE-2025-65945 Vulnerable Application',
    vulnerability: 'Improper Verification of Cryptographic Signature in jws < 3.2.3',
    endpoints: {
      'POST /login': 'Login with username and password',
      'GET /data': 'Get protected data (requires Bearer token)',
    },
    testCredentials: {
      user: { username: 'user1', password: 'password1' },
      admin: { username: 'admin', password: 'admin123' }
    }
  });
});

// Endpoint to create forged token (for demo purposes)
app.post('/create-forged-token', (req, res) => {
  const { header, payload } = req.body;
  
  // Create token with fake secret
  const fakeSecret = 'any-random-fake-secret-12345';
  const token = jws.sign({
    header: header,
    payload: payload,
    secret: fakeSecret
  });

  res.json({
    success: true,
    token: token,
    warning: 'This is a forged token for demonstration purposes'
  });
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`\n[*] Vulnerable application running on http://localhost:${PORT}`);
  console.log(`[*] Using jws version: ${require('jws/package.json').version}`);
  console.log(`[*] This version is VULNERABLE to CVE-2025-65945\n`);
  console.log(`[*] Test credentials:`);
  console.log(`    - User:  user1 / password1`);
  console.log(`    - Admin: admin / admin123\n`);
});
